/*
Copyright (C) 2008-2009, The Perl Foundation.

=head1 NAME

src/pmc/phparray.pmc - PHP Array

=head1 DESCRIPTION

Implementation of the Array datatype.

=head2 VTABLE Functions

=over 4

=cut

*/

#include "pipp_private.h"

#include "parrot/parrot.h"

/*arbitrary choice, as long as it stays constant */
#define PIPP_HASH_SEED 0xF0848EED

#define PIPP_DEBUG

#ifdef PIPP_DEBUG
#  define dprintf(...) { \
    char *dbg = getenv("PMCDEBUG"); \
    if (dbg && strlen(dbg)) { \
        STRING *pstr = Parrot_sprintf_c(interp, __VA_ARGS__);  \
        char *str = Parrot_str_to_cstring(interp, pstr);           \
        fprintf(stderr, "%s", str);        \
        Parrot_str_free_cstring(str);   \
    } \
}
#else
#  define dprintf(...)
#endif

#define PMC_type(pmc) ((pmc)->vtable->base_type)

#define BUCKET_LIST_PREPEND(b, list) \
    if ((list) == NULL) {                 \
        (list) = (b);                       \
        (b)->bucketNext = NULL;           \
        (b)->bucketPrev = NULL;           \
    }                                   \
    else {                              \
        (list)->bucketPrev = (b);           \
        (b)->bucketNext = (list);           \
        (b)->bucketPrev = NULL;           \
        (list) = (b);                       \
    }

#define TABLE_LIST_PREPEND(b, list)  \
    if ((list)->tableHead == NULL) {      \
        (list)->internalPointer = (b);      \
        (list)->tableHead = (b);            \
        (list)->tableTail = (b);            \
    }                                   \
    else {                              \
        (list)->tableHead->tablePrev = (b); \
        (b)->tableNext = (list)->tableHead; \
        (b)->tablePrev = NULL;            \
        (list)->tableHead = (b);            \
    }

#define TABLE_LIST_APPEND(b, list)   \
    if ((list)->tableHead == NULL) {      \
        (list)->internalPointer = (b);      \
        (list)->tableHead = (b);            \
        (list)->tableTail = (b);            \
    }                                   \
    else {                              \
        (list)->tableTail->tableNext = (b); \
        (b)->tablePrev = (list)->tableTail; \
        (b)->tableNext = NULL;            \
        (list)->tableTail = (b);            \
    }

#define TABLE_LIST_DELETE(b, list)  \
        (list)->internalPointer = (b)->tableNext;      \
    if ((list)->tableHead == (b))        \
        (list)->tableHead = (b)->tableNext; \
    else \
        (b)->tablePrev->tableNext = (b)->tableNext;     \
    if ((list)->tableTail == (b))        \
        (list)->tableTail = (b)->tablePrev; \
    else  \
        (b)->tableNext->tablePrev = (b)->tablePrev;     \

#define BUCKET_LIST_DELETE(b, list)  \
        if ((list) == (b))        \
        (list) = (b)->bucketNext; \
    else \
        (b)->bucketPrev->bucketNext = (b)->bucketNext;     \
    if ((b)->bucketNext != NULL)        \
        (b)->bucketNext->bucketPrev = (b)->bucketPrev; \

/* find the highest power of 2 where p >= i */
/* XXX: should have one more iteration on 64-bit systems */
#define NEXT_POW_2(i) \
    (i)--;\
    (i) = ((i) >> 1)  | (i);\
    (i) = ((i) >> 2)  | (i);\
    (i) = ((i) >> 4)  | (i);\
    (i) = ((i) >> 8)  | (i);\
    (i) = ((i) >> 16) | (i);\
    (i)++;\

/* Using KEY_hash_iterator_FLAGS causes Parrot_Key_nextkey_keyed try using
 * Special Magic in Parrot_Key_nextkey_keyed() intended for Hash PMCs. */

#define KEY_pipp_iterator_FLAG PObj_private7_FLAG

typedef struct pipp_bucket {
    struct pipp_bucket * bucketPrev;
    struct pipp_bucket * bucketNext;
    struct pipp_bucket * tablePrev;
    struct pipp_bucket * tableNext;
    PMC                * value;
    STRING             * key;
    INTVAL               hashValue;
    INTVAL               keyIsInt;
    INTVAL               keyInt;
} PippBucket;

typedef struct pipp_hash_table {
    PippBucket ** buckets;
    PippBucket *  tableHead;
    PippBucket *  tableTail;
    PippBucket *  internalPointer;
    PMC        *  iter;
    UINTVAL       elementCount;
    UINTVAL       capacity;
    UINTVAL       hashMask;
    INTVAL        nextIndex;
} PippHashTable;

/* Yay for the semipredicate problem. */
typedef struct pipp_is_int {
    INTVAL intval;
    char   isInt;
} PippIsInt;

typedef enum {
    PIPS_START,
    PIPS_INT_CHAR,
    PIPS_REJECT,
    PIPS_ACCEPT
} PippIntParserState;

PippHashTable* pipp_hash_create(PARROT_INTERP, UINTVAL size);
void           pipp_hash_destroy(PARROT_INTERP, PippHashTable *ht);
void           pipp_hash_empty(PARROT_INTERP, PippHashTable *ht);

void           pipp_hash_sanity_check(PARROT_INTERP, PippHashTable *ht);

void           pipp_hash_renumber(PARROT_INTERP, PippHashTable *ht);
void           pipp_hash_rehash(PARROT_INTERP, PippHashTable *ht);
void           pipp_hash_resize(PARROT_INTERP, PippHashTable *ht, INTVAL new_size);

PippBucket*    pipp_hash_get_bucket(PARROT_INTERP, PippHashTable *ht, STRING *key);
PMC*           pipp_hash_get(PARROT_INTERP, PippHashTable *ht, STRING *key);
PippBucket*    pipp_hash_put(PARROT_INTERP, PippHashTable *ht, STRING *key, PMC *value);
INTVAL         pipp_hash_find(PARROT_INTERP, PippHashTable *ht, STRING *key);
void           pipp_hash_delete(PARROT_INTERP, PippHashTable *ht, STRING *key);

PippBucket*    pipp_hash_push(PARROT_INTERP, PippHashTable *ht, PMC *p_val);
PMC*           pipp_hash_pop(PARROT_INTERP, PippHashTable *ht);
PMC*           pipp_hash_shift(PARROT_INTERP, PippHashTable *ht);
PippBucket*    pipp_hash_unshift(PARROT_INTERP, PippHashTable *ht, PMC *p_val);

void           pipp_hash_visit(PARROT_INTERP, PippHashTable *ht, visit_info *info);
void           pipp_hash_freeze(PARROT_INTERP, PippHashTable *ht, visit_info *info);
void           pipp_hash_thaw(PARROT_INTERP, PippHashTable *ht, visit_info *info);

PippIsInt*     pipp_hash_get_intval(PARROT_INTERP, STRING *key);

/*

=head1 NAME

languages/pipp/src/pipp_hash.c - core functions and data structs for the
PHPArray PMC

=head1 DESCRIPTION

A hashtable contains an array of bucket indexes. Buckets are nodes in a
linked list, each containing a C<void *> key and value. During hash
creation, the type of the value can be set.  All keys are stored as STRINGs.

=head2 Initialization and Finalization Functions

=over 4

=cut

*/

/*

=item C<PippHashTable* pipp_hash_create(PARROT_INTERP, UINTVAL size)>

Create and initialize a new PippHash with at least C<size> buckets.

=cut

*/


PippHashTable* pipp_hash_create(PARROT_INTERP, UINTVAL size) {
    UINTVAL        real_size;
    PippHashTable *ht;

    dprintf("pipp_hash_create called with size = %d\n", size);
    real_size = size;
    NEXT_POW_2(real_size);

    ht = mem_allocate_zeroed_typed(PippHashTable);

    ht->buckets = mem_allocate_n_zeroed_typed(real_size, PippBucket*);
    ht->capacity = real_size;
    ht->hashMask = real_size - 1;
    ht->elementCount = 0;
    ht->nextIndex = 0;
    ht->tableHead = NULL;
    ht->tableTail = NULL;

    return ht;
}

/*

=item C<void pipp_hash_destroy(PARROT_INTERP, PippHashTable *ht)>

Non-recursively free all memory used by this PippHash.

=cut

*/

void pipp_hash_destroy(PARROT_INTERP, PippHashTable *ht) {

   pipp_hash_empty(interp, ht);
   mem_sys_free(ht->buckets);
   mem_sys_free(ht);
}

/*

=item C<void pipp_hash_empty(PARROT_INTERP, PippHashTable *ht)>

Delete all items from this PippHash, leaving the size unchanged.

=cut

*/

void pipp_hash_empty(PARROT_INTERP, PippHashTable *ht) {
   PippBucket *b1, *b2;

   b1 = ht->tableHead;
   while (b1 != NULL) {
       b2 = b1;
       b1 = b1->tableNext;
       mem_sys_free(b2);
   }
   memset(ht->buckets, '\0', ht->capacity);
   ht->tableHead = NULL;
   ht->tableTail = NULL;
   ht->elementCount = 0;
   ht->nextIndex = 0;
}

/*

=back

=head2 Debugging Functions

=over 4

=item C<void pipp_hash_sanity_check(PARROT_INTERP, PippHashTable *ht)>

Iterate through the PippHash, making sure that everything's sane.  This
function is intended only for internal debugging.  If anything's goofy, an
exception with a descriptive message is thrown.

=cut

*/

void pipp_hash_sanity_check(PARROT_INTERP, PippHashTable *ht) {
    UINTVAL     count_tbl_fw, count_tbl_bk, count_bkt_ord, element_count, i,
                expected_bucket, ip_pos;
    INTVAL      max_index, expected_next_index;
    PippBucket *curr_bkt, *cmp_bkt;
    STRING     *curr_key;
    PippIsInt  *isInt;

    element_count = ht->elementCount;

    /* Check that ht->buckets points to a valid location. */
    dprintf("  ****SANITY CHECK****\n");
    if (ht->buckets == NULL && ht->capacity != 0)
        Parrot_ex_throw_from_c_args(interp, NULL, -1,
                "PHPArray corruption: buckets is null in a non-0 capacity hash");

    /* Check that capacity < elementCount and that elementCount is accurate. */
    if (ht->capacity <= ht->elementCount && ht->elementCount)
        Parrot_ex_throw_from_c_args(interp, NULL, -1,
                "PHPArray corruption: element count (%d) >= capacity (%d)",
                ht->elementCount, ht->capacity);

    /* Iterate by bucket order. */
    dprintf("checking element count and hash/bucket consistency by bucket order...\n");
    count_bkt_ord = 0;
    for (i = 0; i < ht->capacity; i++) {
        dprintf("starting bucket #%d\n", i);
        curr_bkt = ht->buckets[i];
        while (curr_bkt) {
            dprintf("bucket #%d has a pair mapping '%Ss'=>'%Ss'\n", i,
                    curr_bkt->key, VTABLE_get_string(interp, curr_bkt->value));
            dprintf("next bucket from 0x%X lives at 0x%X\n", curr_bkt, curr_bkt->bucketNext);
            if (curr_bkt == curr_bkt->bucketNext)
                Parrot_ex_throw_from_c_args(interp, NULL, -1,
                        "PHPArray corruption: curr_bkt == curr_bkt->bucketNext");
            expected_bucket = curr_bkt->hashValue & ht->hashMask;
            if (i != expected_bucket)
                Parrot_ex_throw_from_c_args(interp, NULL, -1,
                        "PHPArray corruption: Bucket in list #%d should be in "
                        "list #%d.", i, expected_bucket);
            curr_bkt = curr_bkt->bucketNext;
            count_bkt_ord++;
        }
        dprintf("done with bucket #%d\n", i);
    }

    if (count_bkt_ord != element_count)
        Parrot_ex_throw_from_c_args(interp, NULL, -1,
                "PHPArray corruption: Bucket order count (%d) is different from"
                " ht->elementCount (%d).", count_bkt_ord, element_count);

    /* Iterate through the table forward and backwards. */
    dprintf("checking element count by table order (forwards)...\n");
    curr_bkt = ht->tableHead;
    count_tbl_fw = 0;
    while (element_count && curr_bkt != NULL) {
        dprintf("found pair mapping '%Ss' => '%Ss'\n", curr_bkt->key,
                VTABLE_get_string(interp, curr_bkt->value));
        count_tbl_fw++;
        if (curr_bkt == curr_bkt->tableNext)
            Parrot_ex_throw_from_c_args(interp, NULL, -1,
                    "PHPArray corruption: curr_bkt == curr_bkt->tableNext");

        curr_bkt = curr_bkt->tableNext;
    }

    dprintf("checking element count by table order (backwards)...\n");
    curr_bkt = ht->tableTail;
    count_tbl_bk = 0;
    while (element_count && (curr_bkt != NULL)) {
        dprintf("found pair mapping '%Ss' => '%Ss'\n", curr_bkt->key,
                VTABLE_get_string(interp, curr_bkt->value));
        if (curr_bkt == curr_bkt->tablePrev)
            Parrot_ex_throw_from_c_args(interp, NULL, -1,
                    "PHPArray corruption: curr_bkt == curr_bkt->tablePrev");
        count_tbl_bk++;
        curr_bkt = curr_bkt->tablePrev;
    }

    if (count_tbl_fw != count_tbl_bk)
        Parrot_ex_throw_from_c_args(interp, NULL, -1,
                "PHPArray corruption: Backwards table order count "
                "(%d) is different from forward table order count (%d).",
                count_tbl_bk, count_tbl_fw);
    if (count_tbl_fw != element_count)
        Parrot_ex_throw_from_c_args(interp, NULL, -1,
                "PHPArray corruption: Table order count (%d) is different "
                "from ht->elementCount (%d).", count_tbl_fw, element_count);

    /* Make sure buckets with keyIsInt are sane. */
    dprintf("Checking that cached keyInt values and nextIndex are consistent...\n");
    curr_bkt = ht->tableHead;
    max_index = -1;
    while (element_count && (curr_bkt = curr_bkt->tableNext)) {
        isInt = pipp_hash_get_intval(interp, curr_bkt->key);
        if (isInt->isInt != curr_bkt->keyIsInt)
            Parrot_ex_throw_from_c_args(interp, NULL, -1, "PHPArray corruption: "
                    "A key is confused about if it's an int.");
        if (curr_bkt->keyIsInt && curr_bkt->keyInt != isInt->intval)
            Parrot_ex_throw_from_c_args(interp, NULL, -1, "PHPArray corruption: "
                    "An int key ('%Ss') has an incorrect value (%d != %d) cached.",
                    curr_bkt->key, curr_bkt->keyInt, isInt->intval);
        if (isInt->isInt && isInt->intval > max_index)
            max_index = isInt->intval;
    }
        /* nextIndex doesn't change when an element is deleted, so it's not
         * possible to predict exactly what it should be for a known set of
         * indicies. */
    if (ht->nextIndex < max_index+1)
        Parrot_ex_throw_from_c_args(interp, NULL, -1, "PHPArray corruption: "
                "ht->nextIndex is %d but shouldn't be less than %d.", ht->nextIndex,
                max_index+1);
    dprintf("ht->nextIndex is %d, which looks plausible\n", ht->nextIndex);


    /*Look for duplicate keys using a exhaustive n^2 algorithm.  Performance
     * isn't a big concern, since this code won't be called very often.  */
    dprintf("looking for duplicate keys...\n");
    if (ht->elementCount) {
        curr_bkt = ht->tableHead;
        while (curr_bkt != ht->tableTail) {
            curr_key = curr_bkt->key;
            cmp_bkt = curr_bkt->tableNext;
            while (cmp_bkt != NULL) {
                if (!Parrot_str_compare(interp, curr_key, cmp_bkt->key))
                    Parrot_ex_throw_from_c_args(interp, NULL, -1,
                            "PHPArray corruption: PHPArray contains duplicate keys.");
                cmp_bkt = cmp_bkt->tableNext;
            }
            curr_bkt = curr_bkt->tableNext;
        }
    }

    /* check that internalPointer is sane */
    dprintf("checking that ht->internalPointer points to something in this PHPArray...\n");
    if (ht->internalPointer != NULL) {
        curr_bkt = ht->tableHead;
        ip_pos = 0;
        while (curr_bkt != NULL && curr_bkt != ht->internalPointer) {
            curr_bkt = curr_bkt->tableNext;
            ip_pos++;
        }
        if (curr_bkt != ht->internalPointer)
            Parrot_ex_throw_from_c_args(interp, NULL, -1,
                    "PHPArray corruption: ht->internalPointer doesn't point to "
                    "an element of this PHPArray.");
        dprintf("internalPointer points at position #%d (0 being the beginning)\n", ip_pos);
    }
    else
        dprintf("internalPointer is NULL, which is just fine\n");
    dprintf("  ****SANITY CHECK FINISHED****\n");
}

/*

=back

=head2 Miscellaneous Housekeeping Functions

=over 4

=item C<void pipp_hash_renumber(PARROT_INTERP, PippHashTable *ht)>

Renumber all numerically-indexed elements of this PippHash, starting from 0.
Numbering is done according to insertion order.

=cut

*/

void pipp_hash_renumber(PARROT_INTERP, PippHashTable *ht) {

    INTVAL curr_idx = 0;
    PippBucket *bkt;

    for (bkt = ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
        if (bkt->keyIsInt) {
            dprintf("renumbering from %d to %d\n", bkt->keyInt, curr_idx);
            bkt->key    = Parrot_str_from_int(interp, curr_idx);
            bkt->keyInt = curr_idx;
            curr_idx++;
        }
    }
    ht->nextIndex = curr_idx;

    /* If any indicies have changed, we need to rehash. */
    if (curr_idx)
        pipp_hash_rehash(interp, ht);
}

/*

=item C<void pipp_hash_rehash(PARROT_INTERP, PippHashTable *ht)>

Recalculate the hash of each element, potentially placing it in another bucket.
This is used when a PippHash grows and has its hashMask changed.

=cut

*/

void pipp_hash_rehash(PARROT_INTERP, PippHashTable *ht) {

    UINTVAL bucket_idx;
    PippBucket *bkt;

    for (bucket_idx = 0; bucket_idx < ht->capacity; bucket_idx++)
        ht->buckets[bucket_idx] = NULL;
    for (bkt = ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
        bucket_idx = bkt->hashValue & ht->hashMask;
        dprintf("putting item with key '%Ss' in bucket #%d\n", bkt->key,
                bucket_idx);
        BUCKET_LIST_PREPEND(bkt, ht->buckets[bucket_idx]);
    }
}


/*

=item C<void pipp_hash_resize(PARROT_INTERP, PippHashTable *ht, INTVAL new_size)>

Increase the capacity and number of buckets of this PippHash.  Resizing implies
rehashing.

=cut

*/

void pipp_hash_resize(PARROT_INTERP, PippHashTable *ht, INTVAL new_size) {

    NEXT_POW_2(new_size);
    ht->capacity = new_size;
    ht->buckets  = mem_allocate_n_zeroed_typed(new_size, PippBucket*);
    ht->hashMask = new_size - 1;
    pipp_hash_rehash(interp, ht);
}

/*

=back

=head2 Hash Manipulation Functions

=over 4

=item C<PippBucket* pipp_hash_get_bucket(PARROT_INTERP, PippHashTable *ht, STRING *key)>

If there is a bucket with a the key C<key>, return a pointer to it.  Otherwise
return NULL.

=cut

*/

PippBucket* pipp_hash_get_bucket(PARROT_INTERP, PippHashTable *ht, STRING *key){
    INTVAL key_hash, bucket_idx;
    PippBucket *bucket;

    key_hash = Parrot_str_to_hashval(interp, key);
    bucket   = ht->buckets[key_hash & ht->hashMask];
    dprintf("pipp_hash_get_bucket called with key '%Ss', has hash 0x%X\n",
            key, key_hash);

    while (bucket != NULL && Parrot_str_compare(interp, bucket->key, key))
        bucket = bucket->bucketNext;
    if (bucket) {
        dprintf("found bucket with key '%Ss'\n", bucket->key);
        return bucket;
    }
    dprintf("bucket not found\n");
    return NULL;
}

/*

=item C<PMC* pipp_hash_get(PARROT_INTERP, PippHashTable *ht, STRING *key)>

If there is a bucket with a the key C<key>, return the value of that bucket.
Otherwise return NULL.

=cut

*/

PMC* pipp_hash_get(PARROT_INTERP, PippHashTable *ht, STRING *key) {
    PippBucket *bucket;

    dprintf("pipp_hash_get called with key '%Ss'\n", key);
    bucket = pipp_hash_get_bucket(interp, ht, key);
    if (bucket)
        return bucket->value;
    dprintf("pipp_hash_get is returning null\n");
    return PMCNULL;
}

/*

=item C<PippBucket* pipp_hash_put(PARROT_INTERP, PippHashTable *ht, STRING *key, PMC *p_val)>

Store C<p_val>, indexed by C<key>, in the hash.  Return the bucket where
C<p_val> was stored.

=cut

*/

PippBucket* pipp_hash_put(PARROT_INTERP, PippHashTable *ht, STRING *key, PMC *p_val) {
    PippIsInt  *isInt;
    PippBucket *first_bucket, *curr_bucket;
    INTVAL      key_hash, bucket_idx;

    key_hash     = Parrot_str_to_hashval(interp, key);
    bucket_idx   = key_hash & ht->hashMask;
    curr_bucket  = ht->buckets[bucket_idx];
    first_bucket = curr_bucket;
    isInt        = pipp_hash_get_intval(interp, key);

    if (PMC_IS_NULL(p_val)) {
        dprintf("pipp_hash_put called: key is '%Ss', p_val is null, hash is "
                "0x%X\n", key, key_hash);
    }
    else {
        dprintf("pipp_hash_put called: key is '%Ss', p_val stringifies to "
                "'%Ss', hash is 0x%X\n", key, VTABLE_get_string(interp, p_val),
                key_hash);
    }

    /* Find the right bucket for the key. */
    while (curr_bucket != NULL &&
           Parrot_str_compare(interp, curr_bucket->key, key)) {
        dprintf("looking for the right bucket: '%Ss' != '%Ss'\n", curr_bucket->key, key);
        curr_bucket = curr_bucket->bucketNext;
    }

    /* If buckets[i] is empty or the key isn't there, make a new bucket. */
    if (curr_bucket == NULL) {

        dprintf("storing value in a new bucket with hash %X\n", key_hash);
        first_bucket = mem_allocate_zeroed_typed(PippBucket);

        first_bucket->key       = key;
        first_bucket->value     = p_val;
        first_bucket->hashValue = key_hash;
        first_bucket->keyIsInt  = isInt->isInt;

        if (first_bucket->keyIsInt)
            first_bucket->keyInt = isInt->intval;

        BUCKET_LIST_PREPEND(first_bucket, ht->buckets[bucket_idx]);
        TABLE_LIST_APPEND(first_bucket, ht);
        curr_bucket = first_bucket;
        ht->elementCount++;

        if (ht->capacity <= ht->elementCount+1) {
            dprintf("time to grow...\n");
            pipp_hash_resize(interp, ht, ht->capacity * 2);
        }
    }
    /* Otherwise replace the contents of an existing bucket. */
    else {
        dprintf("overwriting old value (%Ss) in an existing bucket with hash %X\n",
                VTABLE_get_string(interp, curr_bucket->value), key_hash);
        curr_bucket->key       = key;
        curr_bucket->value     = p_val;
        curr_bucket->hashValue = key_hash;
        curr_bucket->keyIsInt  = isInt->isInt;

        if (curr_bucket->keyIsInt)
            curr_bucket->keyInt = isInt->intval;
    }

    if (isInt->isInt && isInt->intval >= ht->nextIndex)
        ht->nextIndex = isInt->intval + 1;

    mem_sys_free(isInt);
    return curr_bucket;
}

/*

=item C<PippBucket* pipp_hash_find(PARROT_INTERP, PippHashTable *ht, STRING *key)>

If there is a bucket with a the key C<key>, return 1.  Otherwise return 0.

=cut

*/

INTVAL pipp_hash_find(PARROT_INTERP, PippHashTable *ht, STRING *key){
    return pipp_hash_get_bucket(interp, ht, key) != NULL;
}

/*

=item C<void pipp_hash_delete(PARROT_INTERP, PippHashTable *ht, STRING *key)>

If there's a bucket in this hash with the key C<key>, it is deleted.  If
there's no matching bucket, nothing happens.

=cut

*/

void pipp_hash_delete(PARROT_INTERP, PippHashTable *ht, STRING *key){
    PippBucket *b;
    INTVAL      bucket_idx;

    b = pipp_hash_get_bucket(interp, ht, key);

    if (b != NULL) {
        bucket_idx = ht->hashMask & b->hashValue;
        TABLE_LIST_DELETE(b, ht);
        BUCKET_LIST_DELETE(b, ht->buckets[bucket_idx]);
        mem_sys_free(b);
        ht->elementCount--;
    }
}

/*

=back

=head2 Deque Functions

=over 4

=item C<PippBucket* pipp_hash_push(PARROT_INTERP, PippHashTable *ht, PMC *p_val)>

Append a bucket with C<p_val> to the PippHash.  Its index will be determined by
the value of ht->nextIndex.  Pushing onto a PippHash does *not* affect
internalPointer.

=cut

*/

PippBucket* pipp_hash_push(PARROT_INTERP, PippHashTable *ht, PMC *p_val){
    STRING     *s_key;
    PippBucket *bkt;
    INTVAL      key_hash, bucket_idx;

    if (ht->capacity <= ht->elementCount+1) {
        dprintf("time to grow...\n");
        pipp_hash_resize(interp, ht, ht->capacity * 2);
    }

    s_key    = Parrot_str_from_int(interp, ht->nextIndex);
    key_hash = Parrot_str_to_hashval(interp, s_key);
    bkt      = mem_allocate_zeroed_typed(PippBucket);

    bkt->key       = s_key;
    bkt->value     = p_val;
    bkt->hashValue = key_hash;
    bkt->keyIsInt  = 1;
    bkt->keyInt    = ht->nextIndex;

    bucket_idx = bkt->hashValue & ht->hashMask;

    BUCKET_LIST_PREPEND(bkt, ht->buckets[bucket_idx]);
    TABLE_LIST_APPEND(bkt, ht);
    ht->elementCount++;
    ht->nextIndex++;
    dprintf("pushed a value: key is '%Ss', keyInt is %d, hash is 0x%X\n",
            s_key, bkt->keyInt, key_hash)

    return bkt;
}

/*

=item C<PMC* pipp_hash_pop(PARROT_INTERP, PippHashTable *ht)>

Delete the element at the end of this hash, returning its value.  Popping from
a PippHash also resets internalPointer to point at the first element of the
array.

=cut

*/

PMC* pipp_hash_pop(PARROT_INTERP, PippHashTable *ht) {
    INTVAL bl_hash, bucket_idx;
    PippBucket *bucket;
    PMC        *p_val;

    if (ht->elementCount == 0)
        return PMCNULL;

    bucket  = ht->tableTail;
    p_val   = bucket->value;
    bl_hash = bucket->hashValue & ht->hashMask;

    TABLE_LIST_DELETE(bucket, ht);
    BUCKET_LIST_DELETE(bucket, ht->buckets[bl_hash]);
    mem_sys_free(bucket);
    ht->elementCount--;
    ht->internalPointer = ht->tableHead;

    return p_val;
}

/*

=item C<PippBucket* pipp_hash_unshift(PARROT_INTERP, PippHashTable *ht, PMC *p_val)>

Prepend a bucket with C<p_val> to the PippHash.  Its index will be 0 and all
other numerically indexed elements will be renumbered according to insertion
order.  Unshifting also points internalPointer at the first element.

=cut

*/

PippBucket* pipp_hash_unshift(PARROT_INTERP, PippHashTable *ht, PMC *p_val){
    STRING     *s_key;
    PippBucket *bkt;
    INTVAL      key_hash, bucket_idx;

    if (ht->capacity <= ht->elementCount+1) {
        dprintf("time to grow...\n");
        pipp_hash_resize(interp, ht, ht->capacity * 2);
    }

    s_key    = Parrot_str_from_int(interp, 0);
    key_hash = Parrot_str_to_hashval(interp, s_key);
    bkt      = mem_allocate_zeroed_typed(PippBucket);

    bkt->key       = s_key;
    bkt->value     = p_val;
    bkt->hashValue = key_hash;
    bkt->keyIsInt  = 1;
    bkt->keyInt    = 0;

    bucket_idx = bkt->hashValue & ht->hashMask;

    BUCKET_LIST_PREPEND(bkt, ht->buckets[bucket_idx]);
    TABLE_LIST_PREPEND(bkt, ht);
    ht->elementCount++;
    pipp_hash_renumber(interp, ht);
    ht->internalPointer = ht->tableHead;
    dprintf("unshifted a value: key is '%Ss', keyInt is %d, hash is 0x%X\n",
            s_key, bkt->keyInt, key_hash)

    return bkt;
}

/*

=item C<PMC* pipp_hash_shift(PARROT_INTERP, PippHashTable *ht)>

Delete the element at the beginning of this hash, returning its value.  This
also resets internalPointer to point at the first element of the resulting
hash.

=cut

*/

PMC* pipp_hash_shift(PARROT_INTERP, PippHashTable *ht) {
    INTVAL bl_hash, bucket_idx;
    PippBucket *bucket;
    PMC        *p_val;

    if (ht->elementCount == 0)
        return PMCNULL;

    bucket  = ht->tableHead;
    p_val   = bucket->value;
    bl_hash = bucket->hashValue & ht->hashMask;

    TABLE_LIST_DELETE(bucket, ht);
    BUCKET_LIST_DELETE(bucket, ht->buckets[bl_hash]);
    mem_sys_free(bucket);
    ht->elementCount--;
    ht->internalPointer = ht->tableHead;

    return p_val;
}

/*

=back

=head2 Freeze/Thaw Helper Functions

=over 4

=item C<void pipp_hash_visit(PARROT_INTERP, PippHashTable *ht, visit_info *info)>

Dispatch a call to VTABLE_visit to the appropriate internal function.

=cut

*/

void pipp_hash_visit(PARROT_INTERP, PippHashTable *ht, visit_info *info) {
    switch (info->what) {
        case VISIT_THAW_NORMAL:
        case VISIT_THAW_CONSTANTS:
            dprintf("pipp_hash_visit is dispatching to pipp_hash_thaw\n");
            pipp_hash_thaw(interp, ht, info);
            break;
        case VISIT_FREEZE_NORMAL:
        case VISIT_FREEZE_AT_DESTRUCT:
            dprintf("pipp_hash_visit is dispatching to pipp_hash_freeze\n");
            pipp_hash_freeze(interp, ht, info);
            break;
        default:
            Parrot_ex_throw_from_c_args(interp, NULL, 1, "unimplemented visit mode");
            break;
    }
}

/*

=item C<void pipp_hash_freeze(PARROT_INTERP, PippHashTable *ht, visit_info *info)>

Do most of the actual work of serializing this PippHash into C<info>.

=cut

*/

void pipp_hash_freeze(PARROT_INTERP, PippHashTable *ht, visit_info *info) {
    PippBucket *bkt;
    for (bkt = ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
        VTABLE_push_string(interp, info->image_io, bkt->key);
        (info->visit_pmc_now)(interp, bkt->value, info);
    }
}


/*

=item C<void pipp_hash_thaw(PARROT_INTERP, PippHashTable *ht, visit_info *info)>

Unserialize this PippHash into C<info>.

=cut

*/

void pipp_hash_thaw(PARROT_INTERP, PippHashTable *ht, visit_info *info) {
    UINTVAL     i, element_count;
    STRING     *s_key;
    IMAGE_IO   *io;
    PippBucket *bkt;

    io = info->image_io;
    element_count = ht->elementCount;

    for (i = 0; i < element_count; i++) {
        s_key = VTABLE_shift_string(interp, io);
        bkt = pipp_hash_put(interp, ht, s_key, PMCNULL);
        /* XXX: This is hackey.  Find a better way.  It may at some point in
         * the future be a good idea to use a more minimal version of
         * pipp_hash_put here, but that'd be a premature optimization at this
         * point.*/
        ht->elementCount--;
        info->thaw_ptr = &bkt->value;
        (info->visit_pmc_now)(interp, PMCNULL, info);
    }
}


/*

=back

=head2 Miscellaneous Helper Functions

=over 4

=item C<PippIsInt* pipp_hash_get_intval(PARROT_INTERP, STRING *key)>

If C<s> looks like an INTVAL (i.e. /^([-]?[1-9][0-9]|0)*$/) and doesn't cause an
overflow, return a PippIsInt where C<p->intval> contains the INTVAL and
C<p->isInt> is true.  Otherwise, return a PippIsInt where C<p->isInt> is false
and C<p->intval> is undefined.

=cut

*/

PippIsInt* pipp_hash_get_intval(PARROT_INTERP, STRING *key) {
    PippIsInt          *isInt;
    INTVAL              overflow_check;
    UINTVAL             key_len, curr_idx, curr_char, negate;
    PippIntParserState  state;

    isInt    = mem_allocate_zeroed_typed(PippIsInt);
    key_len  = Parrot_str_length(interp, key);
    negate       = 0;
    curr_idx     = 0;
    isInt->isInt = 1;

    state = PIPS_START;
    /* This is basically equivalient to matching against /^([-]?[1-9][0-9]*|0)$/ */
    while (curr_idx < key_len) {
        curr_char = Parrot_str_indexed(interp, key, curr_idx);
        switch (state) {
            case PIPS_START:
                if (curr_char == '-') {
                    negate = 1;
                    state  = PIPS_INT_CHAR;
                }
                else if (curr_char == '0' && key_len == 1) {
                    isInt->intval = 0;
                    isInt->isInt  = 1;
                    return isInt;
                }
                else if (curr_char >= '1' && curr_char <= '9') {
                    isInt->intval = curr_char - '0';
                    state         = PIPS_INT_CHAR;
                }
                else
                    state = PIPS_REJECT;
                break;

            case PIPS_INT_CHAR:
                if (curr_char >= '0' && curr_char <= '9') {
                    overflow_check  = isInt->intval;
                    overflow_check *= 10;
                    overflow_check += (curr_char - '0');
                    if (overflow_check > isInt->intval)
                        isInt->intval = overflow_check;
                    else
                        state = PIPS_REJECT;
                }
                else
                    state = PIPS_REJECT;
                break;

            case PIPS_ACCEPT:
                isInt->isInt = 1;
                return isInt;

            case PIPS_REJECT:
            default:
                isInt->isInt = 0;
                return isInt;

        }
        curr_idx++;
    }
    if (state == PIPS_REJECT) {
        isInt->isInt = 0;
        return isInt;
    }
    if (negate)
        isInt->intval = 0 - isInt->intval;
    return isInt;
}


/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
pmclass PhpArray
    dynpmc
    need_ext
    hll      PHP
    group    pipp_group
    provides array
    provides hash
    maps     Array
    maps     Hash {

    ATTR struct pipp_hash_table *hash_table;

/*

=item C<void init()>

Intialize this PHPArray.

=cut

*/
    VTABLE void init() {

        Parrot_PhpArray_attributes *arr =
            mem_allocate_zeroed_typed(Parrot_PhpArray_attributes);

        arr->hash_table = pipp_hash_create(INTERP, 4);
        PMC_data(SELF)  = arr;

        PObj_custom_mark_destroy_SETALL(SELF);
    }
/*

=item C<void init_pmc(PMC *p)>

Initialize this PHPArray with the passed-in PMC C<p>.  If C<p> is a PHPArray,
its contents are copied directly.  If C<p> is a PMC that provides a hash or
array interface, its contents are copied via the appropriate VTABLE functions.
In any other case, an exception will be thrown.

=cut

*/
    VTABLE void init_pmc(PMC *p) {
        if (PMC_IS_NULL(p))
            SELF.init();
        else
            SELF.assign_pmc(p);
    }

/*

=item C<void destroy()>

Non-recursively free all memory used by this PHPArray.

=cut

*/
    VTABLE void destroy() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_destroy(INTERP, ht);
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<void mark()>

Recursively mark this PHPArray and all its contents as live.

=cut

*/
    VTABLE void mark() {

        PippBucket    *b;
        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        for (b = ht->tableHead; b != NULL; b = b->tableNext) {
            Parrot_gc_mark_PObj_alive(INTERP, (PObj *)b->key);
            Parrot_gc_mark_PObj_alive(INTERP, (PObj *)b->value);
        }
    }

/*

=item C<INTVAL elements()>

Return the number of elements in this PHPArray.

=cut

*/
    VTABLE INTVAL elements() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return ht->elementCount;
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL i_val)>

Store C<i_val> in this PHPArray, indexed by the Key PMC C<key>.

=cut

*/
    VTABLE void set_integer_keyed(PMC *key, INTVAL i_val) {

        PMC *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to set_integer_keyed_str */
            SELF.set_integer_keyed_str(s_key, i_val);

            return;
        }

        /* get the box where the thing will be stored */
        box = SELF.get_pmc_keyed_str(s_key);

        /* autovivify if needed */
        if (PMC_IS_NULL(box)) {
            box = pmc_new(INTERP, PMC_type(SELF));
            SELF.set_pmc_keyed_str(s_key, box);
        }

        /* recurse into that box */
        VTABLE_set_integer_keyed(INTERP, box, next_key, i_val);
    }

/*

=item C<void set_integer_keyed_str (STRING *s_key, INTVAL i_val)>

Store C<i_val> in this PHPArray, indexed by the STRING C<s_key>.

=cut

*/
    VTABLE void set_integer_keyed_str(STRING *s_key, INTVAL i_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Integer);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_integer_native(INTERP, p_val, i_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_integer_keyed_int (INTVAL i_key, INTVAL i_val)>

Store C<i_val> in this PHPArray, indexed by the INTVAL C<i_key>.

=cut

*/
    VTABLE void set_string_keyed_int(INTVAL i_key, INTVAL i_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Integer);
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_integer_native(INTERP, p_val, i_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC *p_val)>

Store C<val> in this PHPArray, indexed by the Key PMC C<key>.

=cut

*/
    VTABLE void set_pmc_keyed(PMC *key, PMC *p_val) {

        PMC *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to set_pmc_keyed_str */
            SELF.set_pmc_keyed_str(s_key, p_val);

            return;
        }

        /* get the box where the thing will be stored */
        box = SELF.get_pmc_keyed_str(s_key);

        /* autovivify if needed */
        if (PMC_IS_NULL(box)) {
            box = pmc_new(INTERP, PMC_type(SELF));
            SELF.set_pmc_keyed_str(s_key, box);
        }

        /* recurse into that box */
        VTABLE_set_pmc_keyed(INTERP, box, next_key, p_val);
    }

/*

=item C<void set_pmc_keyed_str(STRING *s_key, PMC *val)>

Store C<val> in this PHPArray, indexed by the STRING C<s_key>.

=cut

*/
    VTABLE void set_pmc_keyed_str(STRING *s_key, PMC *p_val) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL i_key, PMC *val)>

Store C<val> in this PHPArray, indexed by the INTVAL C<i_key>.

=cut

*/
    VTABLE void set_pmc_keyed_int(INTVAL i_key, PMC *p_val) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_string_keyed(PMC *key, STRING *s_val)>

Store C<s_val> in this PHPArray, indexed by the Key PMC C<key>.

=cut

*/
    VTABLE void set_string_keyed(PMC *key, STRING *s_val) {

        PMC *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to set_string_keyed_str */
            SELF.set_string_keyed_str(s_key, s_val);

            return;
        }

        /* get the box where the thing will be stored */
        box = SELF.get_pmc_keyed_str(s_key);

        /* autovivify if needed */
        if (PMC_IS_NULL(box)) {
            box = pmc_new(INTERP, PMC_type(SELF));
            SELF.set_pmc_keyed_str(s_key, box);
        }

        /* recurse into that box */
        VTABLE_set_string_keyed(INTERP, box, next_key, s_val);
    }

/*

=item C<void set_string_keyed_str(STRING *s_key, STRING *s_val)>

Store C<s_val> in this PHPArray, indexed by the STRING C<s_key>.

=cut

*/
    VTABLE void set_string_keyed_str(STRING *s_key, STRING *s_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_String);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_string_native(INTERP, p_val, s_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_string_keyed_int(INTVAL i_key, STRING *s_val)>

Store C<s_val> in this PHPArray, indexed by the INTVAL C<i_key>.

=cut

*/
    VTABLE void set_string_keyed_int(INTVAL i_key, STRING *s_val) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);
        PMC           *p_val = pmc_new(INTERP, enum_class_String);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_string_native(INTERP, p_val, s_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_number_keyed(PMC *key, FLOATVAL f_val)>

Store C<f_val> in this PHPArray, indexed by the Key PMC C<key>.

=cut

*/
    VTABLE void set_number_keyed(PMC *key, FLOATVAL f_val) {

        PMC *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to set_number_keyed_str */
            SELF.set_number_keyed_str(s_key, f_val);

            return;
        }

        /* get the box where the thing will be stored */
        box = SELF.get_pmc_keyed_str(s_key);

        /* autovivify if needed */
        if (PMC_IS_NULL(box)) {
            box = pmc_new(INTERP, PMC_type(SELF));
            SELF.set_pmc_keyed_str(s_key, box);
        }

        /* recurse into that box */
        VTABLE_set_number_keyed(INTERP, box, next_key, f_val);
    }

/*

=item C<void set_number_keyed_str(STRING *s_key, FLOATVAL f_val)>

Store C<f_val> in this PHPArray, indexed by the STRING C<s_key>.

=cut

*/
    VTABLE void set_number_keyed_str(STRING *s_key, FLOATVAL f_val) {


        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Float);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_number_native(INTERP, p_val, f_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<void set_number_keyed_int(INTVAL i_key, FLOATVAL f_val)>

Store C<f_val> in this PHPArray, indexed by the INTVAL C<i_key>.

=cut

*/
    VTABLE void set_number_keyed_int(INTVAL i_key, FLOATVAL f_val) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);
        PMC           *p_val = pmc_new(INTERP, enum_class_Float);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_number_native(INTERP, p_val, f_val);
        pipp_hash_put(INTERP, ht, s_key, p_val);
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Retrieve the value from this PHPArray which is associated with the Key PMC
C<key>.

=cut

*/
    VTABLE INTVAL get_integer_keyed(PMC *key) {

        PMC    *next_key, *box;
        STRING *s_key;

        if (PObj_get_FLAGS(key) & KEY_pipp_iterator_FLAG)
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                    "can't use an int as an Iterator key");

        /* peel off the next key */
        next_key = key_next(INTERP, key);
        s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to get_integer_keyed_str */

            return SELF.get_integer_keyed_str(s_key);
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return (INTVAL)0;

        /* recurse into that box */
        return VTABLE_get_integer_keyed(INTERP, box, next_key);
    }

/*

=item C<INTVAL get_integer_keyed_str(STRING *s_key)>

Retrieve the value from this PHPArray which is associated with the STRING
C<s_key>.

=cut

*/
    VTABLE INTVAL get_integer_keyed_str(STRING *s_key) {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);
        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_integer(INTERP, p_val);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL i_key)>

Retrieve the value from this PHPArray which is associated with the INTVAL
C<i_key>.

=cut

*/
    VTABLE INTVAL get_integer_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        PMC           *p_val;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_integer(INTERP, p_val);
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Retrieve the value from this PHPArray which is associated with the Key PMC
C<key>.

=cut

*/
    VTABLE PMC *get_pmc_keyed(PMC *key) {

        PMC           *next_key, *box;
        STRING        *s_key;

        /* deal with Iterator stuff */
        if (PObj_get_FLAGS(key) & KEY_pipp_iterator_FLAG) {

            PippHashTable *ht;

            GET_ATTR_hash_table(INTERP, SELF, ht);

            s_key               = ht->internalPointer->key;
            ht->internalPointer = ht->internalPointer->tableNext;
            next_key            = pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, next_key, s_key);

            return next_key;
        }

        /* peel off the next key */
        next_key = key_next(INTERP, key);
        s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to get_pmc_keyed_str */
            return SELF.get_pmc_keyed_str(s_key);
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return PMCNULL;

        /* recurse into that box */
        return VTABLE_get_pmc_keyed(INTERP, box, next_key);
    }

/*

=item C<PMC *get_pmc_keyed_str(STRING *s_key)>

Retrieve the value from this PHPArray which is associated with the STRING
C<s_key>.

=cut

*/
    VTABLE PMC *get_pmc_keyed_str(STRING *s_key) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_get(INTERP, ht, s_key);
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL i_key)>

Retrieve the value from this PHPArray which is associated with the INTVAL
C<i_key>.

=cut

*/
    VTABLE PMC *get_pmc_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_get(INTERP, ht, s_key);
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Retrieve the value from this PHPArray which is associated with the Key PMC
C<key>.

=cut

*/
    VTABLE STRING *get_string_keyed(PMC *key) {

        PMC           *next_key, *box;
        STRING        *s_key;

        /* deal with Iterator stuff */
        if (PObj_get_FLAGS(key) & KEY_pipp_iterator_FLAG) {

            PippHashTable *ht;

            GET_ATTR_hash_table(INTERP, SELF, ht);

            s_key               = ht->internalPointer->key;
            ht->internalPointer = ht->internalPointer->tableNext;

            return s_key;
        }

        /* peel off the next key */
        next_key = key_next(INTERP, key);
        s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to get_string_keyed_str */
            return SELF.get_string_keyed_str(s_key);
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return (INTVAL)0;

        /* recurse into that box */
        return VTABLE_get_string_keyed(INTERP, box, next_key);
    }

/*

=item C<STRING *get_string_keyed_str(STRING *s_key)>

Retrieve the value from this PHPArray which is associated with the STRING
C<s_key>.

=cut

*/
    VTABLE STRING *get_string_keyed_str(STRING *s_key) {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_string(INTERP, p_val);
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL i_key)>

Retrieve the value from this PHPArray which is associated with the INTVAL
C<i_key>.

=cut

*/
    VTABLE STRING *get_string_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        PMC           *p_val;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_string(INTERP, p_val);
    }

/*

=item C<FLOATVAL get_number_keyed(PMC *key)>

Retrieve the value from this PHPArray which is associated with the Key PMC
C<key>.

=cut

*/
    VTABLE FLOATVAL get_number_keyed(PMC *key) {

        PMC    *box, *next_key;
        STRING *s_key;

        if (PObj_get_FLAGS(key) & KEY_pipp_iterator_FLAG)
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                    "You can't use a float as an Iterator key.");

        /* peel off the next key */
        next_key = key_next(INTERP, key);
        s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to get_number_keyed_str */
            return SELF.get_number_keyed_str(s_key);
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return (INTVAL)0;

        /* recurse into that box */
        return VTABLE_get_number_keyed(INTERP, box, next_key);
    }

/*

=item C<FLOATVAL get_number_keyed_str(STRING *s_key)>

Retrieve the value from this PHPArray which is associated with the STRING
C<s_key>.

=cut

*/
    VTABLE FLOATVAL get_number_keyed_str(STRING *s_key) {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_number(INTERP, p_val);
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL i_key)>

Retrieve the value from this PHPArray which is associated with the INTVAL
C<i_key>.

=cut

*/
    VTABLE FLOATVAL get_number_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        PMC           *p_val;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_get(INTERP, ht, s_key);

        return VTABLE_get_number(INTERP, p_val);
    }

/*

=item C<INTVAL exists_keyed(PMC *key)>

Return non-zero if an element keyed by C<key> exists.

=cut

*/
    VTABLE INTVAL exists_keyed(PMC *key) {

        PMC    *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to exists_keyed_str */
            return SELF.exists_keyed_str(s_key);
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return (INTVAL)0;

        /* recurse into that box */
        return VTABLE_exists_keyed(INTERP, box, next_key);
    }

/*

=item C<INTVAL exists_keyed_str(STRING *s_key)>

Return non-zero if an element keyed by C<s_key> exists.

=cut

*/
    VTABLE INTVAL exists_keyed_str(STRING *s_key) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_find(INTERP, ht, s_key);
    }

/*

=item C<INTVAL exists_keyed_int(INTVAL i_key)>

Return non-zero if an element keyed by C<i_key> exists.

=cut

*/
    VTABLE INTVAL exists_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_find(INTERP, ht, s_key);
    }

/*

=item C<void delete_keyed(PMC *key)>

If an element in this PHPArray is keyed by C<key>, delete it.  Otherwise do
nothing.

=cut

*/
    VTABLE void delete_keyed(PMC *key) {

        PMC    *box;

        /* peel off the next key */
        PMC    *next_key = key_next(INTERP, key);
        STRING *s_key    = VTABLE_get_string(INTERP, key);

        /* if there isn't one (i.e. key is null) */
        if (next_key == NULL) {
            /* dispatch to delete_keyed_str */
            SELF.delete_keyed_str(s_key);
            return;
        }

        /* get the box where the thing should be stored */
        box = SELF.get_pmc_keyed_str(s_key);
        if (PMC_IS_NULL(box))
            return;

        /* recurse into that box */
        VTABLE_delete_keyed(INTERP, box, next_key);

        return;
    }

/*

=item C<void delete_keyed_str(STRING *s_key)>

If an element in this PHPArray is keyed by C<key>, delete it.  Otherwise do
nothing.

=cut

*/
    VTABLE void delete_keyed_str(STRING *s_key) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_delete(INTERP, ht, s_key);
    }

/*

=item C<void delete_keyed_int(INTVAL i_key)>

If an element in this PHPArray is keyed by C<key>, delete it.  Otherwise do
nothing.

=cut

*/
    VTABLE void delete_keyed_int(INTVAL i_key) {

        PippHashTable *ht;
        STRING        *s_key = Parrot_str_from_int(INTERP, i_key);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_delete(INTERP, ht, s_key);
    }

/*

=item C<void push_integer(INTVAL i)>

Add an integer with the value C<i> to the end of this PHPArray.

=cut

*/
    VTABLE void push_integer(INTVAL i_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Integer);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        VTABLE_set_integer_native(INTERP, p_val, i_val);
        pipp_hash_push(INTERP, ht, p_val);
    }

/*

=item C<void push_pmc(PMC *p_val)>

Add a PMC with the value C<p_val> to the end of this PHPArray.

=cut

*/
    VTABLE void push_pmc(PMC *p_val) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_push(INTERP, ht, p_val);
    }

/*

=item C<void push_string(STRING *s_val)>

Add a STRING with the value C<s_val> to the end of this PHPArray.

=cut

*/
    VTABLE void push_string(STRING *s_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_String);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        VTABLE_set_string_native(INTERP, p_val, s_val);
        pipp_hash_push(INTERP, ht, p_val);
    }

/*

=item C<void push_float(FLOATVAL f_val)>

Add a FLOATVAL with the value C<f_val> to the end of this PHPArray.

=cut

*/
    VTABLE void push_float(FLOATVAL f_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Float);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        VTABLE_set_number_native(INTERP, p_val, f_val);
        pipp_hash_push(INTERP, ht, p_val);
    }

/*

=item C<INTVAL pop_integer()>

Delete the element at the end of this PHPArray, returning its value as an INTVAL.

=cut

*/
    VTABLE INTVAL pop_integer() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_pop(INTERP, ht);

        return VTABLE_get_integer(INTERP, p_val);
    }

/*

=item C<PMC* pop_pmc()>

Delete the element at the end of this PHPArray, returning its value as a PMC.

=cut

*/
    VTABLE PMC *pop_pmc() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_pop(INTERP, ht);
    }

/*

=item C<STRING* pop_string()>

Delete the element at the end of this PHPArray, returning its value as a STRING.

=cut

*/
    VTABLE STRING *pop_string() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_pop(INTERP, ht);

        return VTABLE_get_string(INTERP, p_val);
    }

/*

=item C<FLOATVAL pop_float()>

Delete the element at the end of this PHPArray, returning its value as a FLOATVAL.

=cut

*/
    VTABLE FLOATVAL pop_float() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_pop(INTERP, ht);

        return VTABLE_get_number(INTERP, p_val);
    }

/*

=item C<void unshift_integer(INTVAL i_val)>

Add an integer with the value C<i_val> to the beginning of this PHPArray.
C<i_val> will be keyed by the INTVAL 0 and all other numerically indexed
elements will be renumbered according to insertion order.

=cut

*/
    VTABLE void unshift_integer(INTVAL i_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Integer);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_integer_native(INTERP, p_val, i_val);

        pipp_hash_unshift(INTERP, ht, p_val);
    }

/*

=item C<void unshift_pmc(PMC *p_val)>

Add a PMC with the value C<p_val> to the beginning of this PHPArray.  C<p_val>
will be keyed by the INTVAL 0 and all other numerically indexed elements will
be renumbered according to insertion order.

=cut

*/
    VTABLE void unshift_pmc(PMC *p_val) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_unshift(INTERP, ht, p_val);
    }

/*

=item C<void unshift_string(STRING *s_val)>

Add a STRING with the value C<s_val> to the beginning of this PHPArray.
C<s_val> will be keyed by the INTVAL 0 and all other numerically indexed
elements will be renumbered according to insertion order.

=cut

*/
    VTABLE void unshift_string(STRING *s_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_String);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_string_native(INTERP, p_val, s_val);

        pipp_hash_unshift(INTERP, ht, p_val);
    }

/*

=item C<void unshift_float(FLOATVAL f_val)>

Add a FLOATVAL with the value C<f_val> to the beginning of this PHPArray.
C<f_val> will be keyed by the INTVAL 0 and all other numerically indexed
elements will be renumbered according to insertion order.

=cut

*/
    VTABLE void unshift_float(FLOATVAL f_val) {

        PippHashTable *ht;
        PMC           *p_val = pmc_new(INTERP, enum_class_Float);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        VTABLE_set_number_native(INTERP, p_val, f_val);

        pipp_hash_unshift(INTERP, ht, p_val);
    }

/*

=item C<INTVAL shift_integer()>

Delete the element at the beginning of this PHPArray, returning its value as an INTVAL.

=cut

*/
    VTABLE INTVAL shift_integer() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_shift(INTERP, ht);

        return VTABLE_get_integer(INTERP, p_val);
    }

/*

=item C<PMC* shift_pmc()>

Delete the element at the beginning of this PHPArray, returning its value as a PMC.

=cut

*/
    VTABLE PMC *shift_pmc() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return pipp_hash_shift(INTERP, ht);
    }

/*

=item C<STRING* shift_string()>

Delete the element at the beginning of this PHPArray, returning its value as a STRING.

=cut

*/
    VTABLE STRING *shift_string() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_shift(INTERP, ht);

        return VTABLE_get_string(INTERP, p_val);
    }

/*

=item C<FLOATVAL shift_float()>

Delete the element at the beginning of this PHPArray, returning its value as a FLOATVAL.

=cut

*/
    VTABLE FLOATVAL shift_float() {

        PippHashTable *ht;
        PMC           *p_val;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        p_val = pipp_hash_shift(INTERP, ht);

        return VTABLE_get_number(INTERP, p_val);
    }

/*

=item C<STRING* name()>

Return the string 'array'.

=cut

*/
    VTABLE STRING* name() {
        return Parrot_str_new_constant(INTERP, "array");
    }

/*

=item C<STRING* get_string()>

Return the string 'Array'.

=cut

*/
    VTABLE STRING* get_string() {
        return Parrot_str_new_constant(INTERP, "Array");
    }

/*

=item C<INTVAL get_bool()>

Return 1 if this PHPArray has 1 or more elements.

=cut

*/
    VTABLE INTVAL get_bool() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        return ht->elementCount > 0;
    }


/*

=item C<void visit(visit_info *info()>

Freeze or thaw the contents of this PHPArray.

=cut

*/
    VTABLE void visit(visit_info *info) {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);
        info->container = SELF;
        pipp_hash_visit(INTERP, ht, info);
        SUPER(info);
    }

/*

=item C<void freeze(visit_info *info()>

After C<visit()> has been called during the freeze process, this VTABLE function
is used to add additional information about the PHPArray to the visit_info
struct.

=cut

*/
    VTABLE void freeze(visit_info *info) {

        PippHashTable *ht;
        PippBucket    *bkt;
        IMAGE_IO      *io;
        UINTVAL        ip_pos;

        SUPER(info);

        GET_ATTR_hash_table(INTERP, SELF, ht);

        io = info->image_io;
        VTABLE_push_integer(INTERP, io, ht->nextIndex);
        VTABLE_push_integer(INTERP, io, ht->capacity);
        VTABLE_push_integer(INTERP, io, ht->elementCount);

        if (ht->internalPointer == NULL) {
            VTABLE_push_integer(INTERP, io, -1);
        }
        else {
            ip_pos = 0;
            for (bkt = ht->tableHead; bkt != ht->internalPointer; bkt = bkt->tableNext)
                ip_pos++;
            VTABLE_push_integer(INTERP, io, ip_pos);
        }
    }

/*

=item C<void thaw(visit_info *info()>

Before C<visit()> is called during the thaw process, this VTABLE function is used
to initialize the empty PHPArray.

=cut

*/
    VTABLE void thaw(visit_info *info) {

        PippHashTable *ht;
        IMAGE_IO      *io;
        INTVAL         next_index, ip_pos;
        UINTVAL        capacity, element_count;

        SUPER(info);
        io = info->image_io;
        next_index    = VTABLE_shift_integer(INTERP, io);
        capacity      = VTABLE_shift_integer(INTERP, io);
        element_count = VTABLE_shift_integer(INTERP, io);
        ip_pos        = VTABLE_shift_integer(INTERP, io);

        GET_ATTR_hash_table(INTERP, SELF, ht);
        pipp_hash_resize(INTERP, ht, capacity);

        ht->elementCount  = element_count;
        ht->nextIndex     = next_index;

        /* used during thawfinish */
        info->extra       = (void *)ip_pos;
    }

/*

=item C<void thawfinish(visit_info *info()>

After C<visit()> is called during the thaw process, this VTABLE function is
used to make any changes to the newly thawed PHPArray which could not be made
during the thaw process.

=cut

*/
    VTABLE void thawfinish(visit_info *info) {

        PippHashTable *ht;
        INTVAL         ip_pos = (INTVAL)info->extra;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ip_pos == -1) {
            ht->internalPointer = NULL;
        }
        else {

            PMC *key;

            for (ht->internalPointer = ht->tableHead; ip_pos > 0; ip_pos--) {
                ht->internalPointer = ht->internalPointer->tableNext;
            }
        }
    }

/*

=item C<PMC *get_iter()>

Return an Iterator over this PHPArray.  When using an Iterator over PHPArrays,
it is a very good idea to use the C<iter> opcode as follows:

 $P0 = new 'PhpArray'
 $P1 = iter $P0

This ensures that the Iterator and the PHPArray's internal pointer stay in
sync.  Using an Iterator and a PHPArray any other way may lead to mysterious
failures.

=cut

*/
    VTABLE PMC *get_iter() {

        PippHashTable *ht;
        PippBucket    *bkt;
        STRING        *get_key = CONST_STRING(INTERP, "get_key");
        PMC           *iter  = pmc_new_init(INTERP, enum_class_Iterator, SELF);
        PMC           *key;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        /* yup, only one iterator per PhpArray */
        ht->iter = iter;

        Parrot_PCCINVOKE(INTERP, iter, get_key, "->P", &key);

        /* set the key's flags so get_x_keyed() knows when it's being called
         * from an Iterator. */
        PObj_get_FLAGS(key) = KEY_pipp_iterator_FLAG | KEY_integer_FLAG;


        /* Get the Iterator and ht->internalPointer in sync. */
        bkt = ht->tableHead;

        while (bkt != ht->internalPointer) {
            VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_GET_NEXT);
            bkt = bkt->tableNext;
        }

        return iter;
    }

/*

=item C<PMC* clone()>

Return a deep clone of this PHPArray.

=cut

*/
    VTABLE PMC *clone() {

        PMC           *cloned_value;
        STRING        *cloned_key;
        PippBucket    *bkt;
        PippHashTable *orig_ht, *cloned_ht;
        PMC           *cloned_pmc = pmc_new(INTERP, PMC_type(SELF));

        GET_ATTR_hash_table(INTERP, SELF, orig_ht);
        GET_ATTR_hash_table(INTERP, cloned_pmc, cloned_ht);
        pipp_hash_create(INTERP, orig_ht->capacity);

        for (bkt = orig_ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
            cloned_key   = Parrot_str_copy(INTERP, bkt->key);
            cloned_value = VTABLE_clone(INTERP, bkt->value);
            pipp_hash_put(INTERP, cloned_ht, cloned_key, cloned_value);
        }
        return cloned_pmc;
    }


/*

=item C<void assign_pmc(PMC *src)>

If C<src> is an aggregate PMC (i.e. one that does hash and/or array), use an
Iterator to copy each key/value pair into this PHPArray.  If C<src> is a
PHPArray, just make a clone.

=cut

*/
    VTABLE void assign_pmc(PMC *src) {

        PippHashTable *my_ht;

        GET_ATTR_hash_table(INTERP, SELF, my_ht);

        if (PMC_type(src) == PMC_type(SELF)) {

            PippBucket    *bkt;
            PippHashTable *src_ht;

            GET_ATTR_hash_table(INTERP, src, src_ht);

            pipp_hash_empty(INTERP, my_ht);
            pipp_hash_resize(INTERP, my_ht, src_ht->elementCount);

            for (bkt = src_ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
                STRING *key_copy   = Parrot_str_copy(INTERP,  bkt->key);
                PMC    *value_copy = VTABLE_clone(INTERP, bkt->value);
                pipp_hash_put(INTERP, my_ht, key_copy, value_copy);
            }
        }
        else if (VTABLE_does(INTERP, src, CONST_STRING(INTERP, "array")) ||
                 VTABLE_does(INTERP, src, CONST_STRING(INTERP, "hash"))) {

            PMC *iter = VTABLE_get_iter(INTERP, src);

            pipp_hash_empty(INTERP, my_ht);
            pipp_hash_resize(INTERP, my_ht, VTABLE_elements(INTERP, src));

            while (VTABLE_get_bool(INTERP, iter)) {
                PMC    *key        = VTABLE_shift_pmc(INTERP, iter);
                PMC    *value_copy = VTABLE_get_pmc_keyed(INTERP, src, key);
                STRING *key_copy   = VTABLE_get_string(INTERP, key);

                pipp_hash_put(INTERP, my_ht, key_copy, value_copy);
            }
        }
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_PARROT_USAGE_ERROR,
                    "can't assign a non-aggregate PMC to a PhpArray");
    }
/*

=item C<PMC* add(PMC *src, PMC *dest)>

Copy all key/value pairs in C<SELF> and C<src> into C<dest>.  All values in
C<dest> are deleted.  If the same key is in both C<src> and C<SELF>, the value
from C<SELF> will be used.

=cut

*/
    VTABLE PMC *add(PMC *src, PMC *dest) {

        dest = SELF.clone();
        VTABLE_i_add(INTERP, dest, src);

        return dest;
    }
/*

=item C<PMC* i_add(PMC *src)>

Copy all key/value pairs from C<src> into C<SELF>.  If the same key is in both
C<src> and C<SELF>, the value from C<SELF> will be used.

=cut

*/
    VTABLE void i_add(PMC *src) {

        STRING        *key_copy;
        PMC           *value_copy;
        PippHashTable *my_ht;

        GET_ATTR_hash_table(INTERP, SELF, my_ht);

        if (PMC_type(SELF) == PMC_type(src)) {

            PippBucket    *bkt;
            PippHashTable *src_ht;

            GET_ATTR_hash_table(INTERP, src, src_ht);

            for (bkt = src_ht->tableHead; bkt != NULL; bkt = bkt->tableNext) {
                key_copy   = Parrot_str_copy(INTERP, bkt->key);
                value_copy = VTABLE_clone(INTERP, bkt->value);
                /* TODO: This isn't especially efficient. */
                if (!pipp_hash_find(INTERP, my_ht, key_copy))
                    pipp_hash_put(INTERP, my_ht, key_copy, value_copy);
            }
        }
        else if (VTABLE_does(INTERP, src, CONST_STRING(INTERP, "array")) ||
                VTABLE_does(INTERP, src, CONST_STRING(INTERP, "hash"))) {

            PMC *key, *iter;

            iter = VTABLE_get_iter(INTERP, src);
            pipp_hash_empty(INTERP, my_ht);
            pipp_hash_resize(INTERP, my_ht, VTABLE_elements(INTERP, src));

            while (VTABLE_get_bool(INTERP, iter)) {
                key        = VTABLE_shift_pmc(INTERP, iter);
                value_copy = VTABLE_get_pmc_keyed(INTERP, src, key);
                key_copy   = VTABLE_get_string(INTERP, key);

                pipp_hash_put(INTERP, my_ht, key_copy, value_copy);
            }
        }
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_PARROT_USAGE_ERROR,
                    "can't add a non-aggregate PMC to a PhpArray");
    }

/*

=item C<INTVAL is_equal(PMC *other)>

Return true if C<SELF> and C<other> contain the same key/value pairs and have
the same number of elements.  Order is not important.

=cut

*/

    VTABLE INTVAL is_equal(PMC *other) {
        return !Parrot_PhpArray_cmp(INTERP, SELF, other);
    }

/*

=item C<INTVAL is_equal_num(PMC *other)>

Determine equality between a PHPArray and a number.  PHP's documentation says
that an array is always greater than a number, so this function returns 0.
See http://us.php.net/manual/en/language.operators.comparison.php .

=cut

*/

    VTABLE INTVAL is_equal_num(PMC *other) {
        return 0;
    }

/*

=item C<INTVAL is_equal_string(PMC *other)>

Determine equality between a PHPArray and a string.  PHP's documentation says
that an array is always greater than a string, so this function returns 0.
See http://us.php.net/manual/en/language.operators.comparison.php .

=cut

*/

    VTABLE INTVAL is_equal_string(PMC *other) {
        return 0;
    }

/*

=item C<INTVAL is_same(PMC *other)>

Return true if C<SELF> and C<other> point to the same place in memory.

=cut

*/

    VTABLE INTVAL is_same(PMC *other) {
        return SELF == other;
    }

/*

=item C<INTVAL cmp(PMC *other)>

Compare C<SELF> to C<other>.  A PHPArray with fewer elements is always
considered to be less than one with more elements.  Two PHPArrays of the same
size are comparable if they have the same keys.  In this case, C<a> > C<b> if
the first unequal value of C<a> is greater, according to the internal ordering
of C<a>.  This means it's possible for both C<a> > C<b> and C<b> > C<a> to be
true.

If the arrays are comparable and C<SELF> is larger, cmp returns 1.  If they're
equal, cmp returns 0.  If C<other> is larger, cmp returns -1.

If C<SELF> and the other PMC are not comparable, an exception is thrown.  This
is to allow the PHP implementation to return null for a comparison between two
non-comparable PHPArrays.

=cut

*/

    VTABLE INTVAL cmp(PMC *other) {

        PippBucket    *my_bkt;
        PippHashTable *my_ht;

        GET_ATTR_hash_table(INTERP, SELF, my_ht);

        if (PMC_type(SELF) == PMC_type(other)) {

            PippHashTable *other_ht;

            GET_ATTR_hash_table(INTERP, other, other_ht);

            if (SELF == other)
                return 0;

            if (my_ht->elementCount != other_ht->elementCount)
                return my_ht->elementCount > other_ht->elementCount ? 1 : -1;

            for (my_bkt = my_ht->tableHead; my_bkt != NULL; my_bkt = my_bkt->tableNext) {

                INTVAL cmp;
                PippBucket *other_bkt = pipp_hash_get_bucket(INTERP, other_ht, my_bkt->key);

                if (other_bkt == NULL)
                    Parrot_ex_throw_from_c_args(INTERP, NULL, 1, "non-comparable PhpArrays");

                cmp = VTABLE_cmp(INTERP, my_bkt->value, other_bkt->value);

                if (cmp)
                    return cmp;
            }
            return 0;
        }
        else if (VTABLE_does(INTERP, other, CONST_STRING(INTERP, "array")) ||
                 VTABLE_does(INTERP, other, CONST_STRING(INTERP, "hash"))) {

            PMC    *other_value;
            STRING *other_key;
            INTVAL  cmp;
            PMC    *iter = VTABLE_get_iter(INTERP, other);

            while (VTABLE_get_bool(INTERP, iter)) {

                other_key = VTABLE_shift_string(INTERP, iter);
                my_bkt    = pipp_hash_get_bucket(INTERP, my_ht, other_key);

                if (my_bkt == NULL)
                    Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                            "this PhpArray is non-comparable with this %Ss",
                            VTABLE_name(INTERP, other));

                other_value = VTABLE_get_pmc_keyed_str(INTERP, other, other_key);
                cmp = VTABLE_cmp(INTERP, my_bkt->value, other_value);

                if (cmp != 0)
                    return cmp;
            }
            return 0;
        }
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_PARROT_USAGE_ERROR,
                    "can't assign a non-aggregate PMC to a PhpArray");
    }

/*

=item C<INTVAL cmp_num(PMC *other)>

In PHP, arrays are always greater than numeric types.  This function always
returns 1.

=cut

*/

    VTABLE INTVAL cmp_num(PMC *other) {
        return 1;
    }


/*

=item C<INTVAL cmp_string(PMC *other)>

In PHP, arrays are always greater than strings.  This function always returns
1.

=cut

*/

    VTABLE INTVAL cmp_string(PMC *other) {
        return 1;
    }


/*

=item C<STRING *get_repr()>

Return a string representation of the contents of this PhpArray.  The format of
this string is the same as a Parrot Hash's C<get_repr()>:

 {0: 4, 4: 323, 'foo': 9999999}

=cut

*/

    VTABLE STRING *get_repr() {

        PippHashTable *ht;
        PippBucket    *bkt;
        STRING        *key_str, *val_str;
        STRING        *repr = CONST_STRING(INTERP, "{");
        PMC           *undef;

        GET_ATTR_hash_table(INTERP, SELF, ht);
        bkt = ht->tableHead;
        undef = pmc_new(INTERP, enum_class_Undef);

        while (bkt != NULL) {

            if (bkt->keyIsInt)
                key_str = Parrot_sprintf_c(INTERP, "%Ss: ", bkt->key);
            else
                key_str = Parrot_sprintf_c(INTERP, "\"%Ss\": ", bkt->key);

            repr    = Parrot_str_append(INTERP, repr, key_str);
            val_str = VTABLE_get_string(INTERP, bkt->value);
            repr    = Parrot_str_append(INTERP, repr, val_str);

            if (bkt->tableNext != NULL)
                repr = Parrot_str_append(INTERP, repr, CONST_STRING(INTERP, ", "));

            bkt = bkt->tableNext;
        }
        repr = Parrot_str_append(INTERP, repr, CONST_STRING(INTERP, "}"));
        return repr;
    }

/*

=back

=head2 Methods

=over 4

=item C<METHOD void next()>

Advance the internal pointer to the next element.  This method emulates the
behavior of PHP's C<next()> function.

=cut

*/
    METHOD next() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ht->internalPointer != NULL) {
            if (ht->iter) {
                STRING *get_key = CONST_STRING(INTERP, "get_key");
                PMC    *key;

                Parrot_PCCINVOKE(INTERP, ht->iter, get_key, "->P", &key);
                VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_GET_NEXT);
            }
            ht->internalPointer = ht->internalPointer->tableNext;
        }
        RETURN(void);
    }

/*

=item C<METHOD void prev()>

Move the internal pointer to the previous element.  This method emulates the
behavior of PHP's C<prev()> function.

=cut

*/
    METHOD prev() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ht->internalPointer != NULL) {
            if (ht->iter) {
                PMC    *key;
                STRING *get_key = CONST_STRING(INTERP, "get_key");

                Parrot_PCCINVOKE(INTERP, ht->iter, get_key, "->P", &key);
                VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_GET_PREV);
            }
            ht->internalPointer = ht->internalPointer->tablePrev;
        }
        RETURN(void);
    }

/*

=item C<METHOD void reset()>

Move the internal pointer to the first element of this PhpArray, according to
insertion order.  This method emulates the behavior of PHP's C<reset()>
function.

=cut

*/
    METHOD reset() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        ht->internalPointer = ht->tableHead;
        if (ht->iter) {
            PMC    *key;
            STRING *get_key = CONST_STRING(INTERP, "get_key");

            Parrot_PCCINVOKE(INTERP, ht->iter, get_key, "->P", &key);
            VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_FROM_START);
        }
        RETURN(void);
    }

/*

=item C<METHOD void end()>

Move the internal pointer to the last element of this PhpArray, according to
insertion order.  This method emulates the behavior of PHP's C<end()> function.

=cut

*/
    METHOD end() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        ht->internalPointer = ht->tableTail;
        if (ht->iter) {
            PMC    *key;
            STRING *get_key = CONST_STRING(INTERP, "get_key");

            Parrot_PCCINVOKE(INTERP, ht->iter, get_key, "->P", &key);
            VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_FROM_END);
        }
        RETURN(void);
    }

/*

=item C<METHOD STRING* key()>

Return the key of the element pointed to by the internal pointer.  If the
internal pointer does not point at a valid element, the empty string is
returned.  This method has no side-effects and does not modify the internal
pointer.

=cut

*/
    METHOD key() {

        STRING        *s_key;
        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ht->internalPointer)
            s_key = Parrot_str_copy(INTERP, ht->internalPointer->key);
        else
            s_key = CONST_STRING(INTERP, "");

        RETURN(STRING *s_key);
    }

/*

=item C<METHOD PMC* current()>

Return a clone of value of the element pointed to by the internal pointer.  If
the internal pointer does not point at a valid element, PMCNULL is returned.
This method has no side-effects and does not modify the internal pointer.

=cut

*/
    METHOD current() {

        PMC           *p_val;
        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ht->internalPointer)
            p_val = VTABLE_clone(INTERP, ht->internalPointer->value);
        else
            p_val = PMCNULL;

        RETURN(PMC *p_val);
    }

/*

=item C<METHOD PMC* each()>

Return a PhpArray containing the key/value pair pointed to by the internal
pointer, then advance the internal pointer to the next pair.  The returned
PhpArray has the following key/value pairs, in this order:

=over 4

=item * 1       => value

=item * "value" => value

=item * 0       => key

=item * "key"   => key

=back

where C<key> and C<value> are the key and value from this PhpArray.  If the
internal pointer does not point to a valid element, a PhpBoolean C<false> will
be returned.

=cut

*/
    METHOD each() {

        PMC           *keys, *p_val, *p_key;
        STRING        *s_key;
        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        if (ht->internalPointer != NULL) {

            PippHashTable *keys_ht;

            p_val = ht->internalPointer->value;
            s_key = ht->internalPointer->key;
            p_key = pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, p_key, s_key);

            keys = pmc_new(INTERP, PMC_type(SELF));
            GET_ATTR_hash_table(INTERP, keys, keys_ht);
            pipp_hash_put(INTERP, keys_ht, CONST_STRING(INTERP, "1"), VTABLE_clone(INTERP, p_val));
            pipp_hash_put(INTERP, keys_ht, CONST_STRING(INTERP, "value"), p_val);
            pipp_hash_put(INTERP, keys_ht, CONST_STRING(INTERP, "0"), VTABLE_clone(INTERP, p_key));
            pipp_hash_put(INTERP, keys_ht, CONST_STRING(INTERP, "key"), p_key);

            ht->internalPointer = ht->internalPointer->tableNext;
            if (ht->iter) {
                PMC    *key;
                STRING *get_key = CONST_STRING(INTERP, "get_key");

                Parrot_PCCINVOKE(INTERP, ht->iter, get_key, "->P", &key);
                VTABLE_nextkey_keyed(INTERP, key, SELF, ITERATE_GET_NEXT);
            }

        }
        else {
            keys = pmc_new(INTERP, dynpmc_PhpBoolean);
            VTABLE_set_integer_native(INTERP, keys, 0);
        }

        RETURN(PMC *keys);
    }

/*



=item C<PMC* to_number()>

=cut

*/
    METHOD to_number() {
        RETURN(PMC *SELF);
    }

/*

=item C<METHOD void sanity_check()>

Check if everything about the PippHashTable looks sane.  If anything looks
broken, the code will throw an exception.

=cut

*/
    METHOD sanity_check() {

        PippHashTable *ht;

        GET_ATTR_hash_table(INTERP, SELF, ht);

        pipp_hash_sanity_check(INTERP, ht);
    }

}

/*

=back

=head1 AUTHORS

=over 4

=item Christoph Otto

=item Francois Perrad

=back

=cut

*/


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
